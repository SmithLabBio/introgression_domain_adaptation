// set up the first simulation
// this is no migration
// there is background selection
// neutral mutations are added after the fact via tree sequence recording


initialize() {
        // initialize tree sequence recording
        initializeTreeSeq();
        defineConstant("burnin", 2500);
 
        // this mutation rate should be proportional to the number of deleterious mutations.
        // so, if the overall mutation rate is 1e-8, and 75% of mutations are deleterious.
        // we would initialize this mutatation rate to .75 * 1e-8 = 7.5e-9
        // the neutral mutation rate would be .25 * 1e-8 = 2.5e-9
        initializeMutationRate(mu*propdel);

        // m1 mutation type: deleterious
        initializeMutationType("m1", 0.25, "g", -0.0133, 0.35);
        initializeMutationType("m2", 0.25, "g", -0.00133, 0.35);
        initializeMutationType("m3", 0.5, "f", 0);

        // genomic types
        initializeGenomicElementType("g1", m3, 1.0);
        initializeGenomicElementType("g2", c(m3,m1), c(1-propdel, propdel));
        initializeGenomicElementType("g3", c(m3,m2), c(1-propdel, propdel));

        genomelines = readFile("genomic_map_"+rep+".txt");
        for (line in genomelines)
        {
                components = strsplit(line, "\t");
                thisstart = asInteger(components[0]); 
                thisend = asInteger(components[1]);
                thistype = components[2];
                if (thistype == "g1")
                {
                                initializeGenomicElement(g1, thisstart, thisend-1);
                }
                else if (thistype == "g2")
                {
                                initializeGenomicElement(g2, thisstart, thisend-1);
                }
                else if (thistype == "g3")
                {
                                initializeGenomicElement(g3, thisstart, thisend-1);
                }

        }


        // read rec map
        map = readCSV("recombination_map_"+rep+".txt", c("ends", "rates"), sep="\t");
        ends = map.getValue("ends");
        rates = map.getValue("rates");
        initializeRecombinationRate(rates, ends);
}

// create a population of 1250individuals
1 early(){
        sim.addSubpop("p1", ne);
        community.rescheduleScriptBlock(s3, asInteger(tdiv)+burnin, asInteger(tdiv)+burnin);
        community.rescheduleScriptBlock(s4, burnin, burnin);
        community.rescheduleScriptBlock(s5, asInteger(tdiv / 2)+burnin, asInteger(tdiv / 2)+burnin);

}

// split the two populations
s4 25000 early(){
        sim.addSubpopSplit("p2", ne, p1);
        p1.setSubpopulationSize(ne);
        sim.treeSeqRememberIndividuals(sim.subpopulations.individuals);
}

// migration
s5 25000 early(){
        p1.setMigrationRates(p2, migrate);
        p2.setMigrationRates(p1, migrate);
 }


s3 13750 late() {
        cat("Final random seed: " + getSeed() + "\n");
        name = "mig_bgs_"+rep+".trees";
        sim.treeSeqOutput(name);
}
